<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Prism Viewer</title>
  <style>
    html,body { height:100%; margin:0; background:#000; }
    #newsFrame { width:100%; height:100%; border:0; display:block; }
    #overlay {
      position:fixed; right:8px; top:8px; z-index:9999;
      background:rgba(0,0,0,0.6); color:#fff; padding:6px 8px; border-radius:6px; font-size:13px;
    }
  </style>
</head>
<body>
  <div id="overlay">상태: <span id="status">연결중...</span></div>
  <iframe id="newsFrame" src="/proxy?url=https%3A%2F%2Fnews.naver.com" allow="autoplay"></iframe>

  <script>
    // 설정: server 주소(배포 후 실제 도메인으로 바꿔)
    const SERVER = location.origin; // 권장: 동일 origin (Railway 도메인)
    // room은 쿼리 혹은 기본 'default'
    const params = new URLSearchParams(location.search);
    const room = params.get('room') || 'default';

    const statusEl = document.getElementById('status');
    const iframe = document.getElementById('newsFrame');

    // WebSocket
    const wsProto = (location.protocol === 'https:') ? 'wss:' : 'ws:';
    const wsUrl = `${wsProto}//${location.host}/?type=viewer&room=${encodeURIComponent(room)}`;
    const ws = new WebSocket(wsUrl);

    ws.onopen = () => statusEl.textContent = '연결됨';
    ws.onclose = () => statusEl.textContent = '연결 끊김';
    ws.onerror = (e) => statusEl.textContent = '오류';

    // Helper: try to perform scrolling and navigation inside iframe.
    // Because we proxy pages via /proxy, iframe content is same-origin (served from our domain),
    // so we can access iframe.contentWindow and manipulate DOM.
    function safeExec(fn) {
      try {
        const win = iframe.contentWindow;
        if (!win) return;
        fn(win);
      } catch (e) {
        console.warn('safeExec failed', e);
      }
    }

    ws.onmessage = (ev) => {
      let msg = ev.data;
      // expected commands: JSON or simple strings
      // examples:
      // "scrollDown", "scrollUp", "go:https://...", "click:selector", "eval:alert(1)"
      try {
        const obj = JSON.parse(msg);
        if (obj.cmd === 'goto') {
          iframe.src = `/proxy?url=${encodeURIComponent(obj.url)}`;
          return;
        }
        // add other json commands as needed
      } catch (e) {
        // not json, treat as legacy string
      }

      if (msg === 'scrollDown') {
        safeExec(win => win.scrollBy(0, 400));
      } else if (msg === 'scrollUp') {
        safeExec(win => win.scrollBy(0, -400));
      } else if (msg.startsWith('go:')) {
        const url = msg.slice(3);
        iframe.src = `/proxy?url=${encodeURIComponent(url)}`;
      } else if (msg.startsWith('eval:')) {
        const code = msg.slice(5);
        safeExec(win => {
          try { win.eval(code); } catch (e) { console.warn(e); }
        });
      } else if (msg.startsWith('click:')) {
        const sel = msg.slice(6);
        safeExec(win => {
          try {
            const el = win.document.querySelector(sel);
            if (el) el.click();
          } catch (e) { console.warn(e); }
        });
      } else {
        // fallback: try to eval as JS
        safeExec(win => {
          try { win.eval(msg); } catch (e) { console.warn(e); }
        });
      }
    };
  </script>
</body>
</html>
